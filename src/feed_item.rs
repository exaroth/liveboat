use crate::feed::Feed;

use chrono::DateTime;

#[cfg(not(test))]
use chrono::Local;

#[cfg(test)]
use chrono::Utc;

use libnewsboat::matchable::Matchable;
use rusqlite::Error as SQLiteError;
use rusqlite::Row;
use serde::ser::{Serialize, SerializeStruct, Serializer};
use std::cell::RefCell;
use std::fmt;
use std::sync::Arc;


#[cfg(not(test))]
fn now() -> DateTime<Local> {
    Local::now()
}

#[cfg(test)]
fn now() -> DateTime<Utc> {
    DateTime::from_timestamp(1733974974, 0).unwrap()
}

/// Container for storing and operating
/// on the newsboat article items.
#[derive(Debug, Clone)]
pub struct FeedItem {
    feed_url: String,
    title: String,
    url: String,
    author: String,
    desc: String,
    date: i64,
    unread: bool,
    content: String,
    guid: i64,
    enc_url: Option<String>,
    enc_mime: Option<String>,
    flags: Option<String>,
    pub feed_ptr: Option<Arc<RefCell<Feed>>>,
}

impl FeedItem {
    /// Initialize new article item from db row.
    pub fn from_db_row(row: &Row) -> Result<FeedItem, SQLiteError> {
        let feed_item = FeedItem {
            feed_url: row.get(0)?,
            title: row.get(2)?,
            url: row.get(3)?,
            author: row.get(4)?,
            desc: row.get(5)?,
            date: row.get(6)?,
            unread: row.get(7)?,
            content: row.get(8)?,
            guid: row.get(9)?,
            enc_url: row.get(10)?,
            enc_mime: row.get(11)?,
            flags: row.get(12)?,
            feed_ptr: None,
        };
        Ok(feed_item)
    }

    pub fn feed_url(&self) -> &String {
        return &self.feed_url;
    }

    #[allow(dead_code)]
    pub fn title(&self) -> &String {
        return &self.title;
    }

    #[allow(dead_code)]
    pub fn guid(&self) -> i64 {
        return self.guid;
    }

    /// set a pointer to feed associated with the article.
    pub fn set_ptr(&mut self, f_p: Arc<RefCell<Feed>>) {
        self.feed_ptr = Some(f_p)
    }

    pub fn date(&self) -> i64 {
        return self.date;
    }

    /// Return age of the article (in days).
    pub fn age(&self) -> i64 {
        let tnow = now();
        if let Some(d) = DateTime::from_timestamp(self.date, 0) {
            let delta = tnow.signed_duration_since(d);
            return delta.num_days();
        };
        return 0;
    }
    pub fn is_unread(&self) -> bool {
        return self.unread;
    }

    #[allow(dead_code)]
    pub fn new(
        title: &str,
        url: &str,
        feed_url: &str,
        author: &str,
        desc: &str,
        date: i64,
        unread: bool,
        content: &str,
        guid: i64,
    ) -> FeedItem {
        return FeedItem {
            title: title.to_string(),
            url: url.to_string(),
            feed_url: feed_url.to_string(),
            author: author.to_string(),
            desc: desc.to_string(),
            date: date,
            unread: unread,
            content: content.to_string(),
            guid: guid,
            enc_url: None,
            enc_mime: None,
            flags: None,
            feed_ptr: None,
        };
    }
}

impl Matchable for FeedItem {
    /// Returns filter attributes which are used by newsboat
    /// to generate query feeds.
    fn attribute_value(&self, attr: &str) -> Option<String> {
        match attr {
            "title" => Some(self.title.clone()),
            "link" => Some(self.url.clone()),
            "author" => Some(self.author.clone()),
            "unread" => {
                let unread = if self.unread {
                    String::from("yes")
                } else {
                    String::from("no")
                };
                Some(unread)
            }
            "date" => Some(format!("{}", self.date)),
            "age" => Some(format!("{}", self.age())),
            "content" => Some(self.content.clone()),
            "guid" => Some(format!("{}", self.guid)),
            "enclosure_url" => opt_attr_val(&self.enc_url),
            "enclosure_type" => opt_attr_val(&self.enc_mime),
            "flags" => opt_attr_val(&self.flags),
            // This index is generated by the newsboat when rendering article
            // list so we skip it during filtering.
            "articleindex" => Some(String::new()),
            _ => {
                if let Some(feed) = &self.feed_ptr {
                    feed.borrow().attribute_value(attr)
                } else {
                    None
                }
            }
        }
    }
}

impl fmt::Display for FeedItem {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FeedItem::
            feed url {}:
            title: {}
            url: {}
            date: {}
            unread: {}",
            self.feed_url, self.title, self.url, self.date, self.unread,
        )
    }
}

/// Utility used for processing Optional, string based attrs
/// so we can still utilize them even if not set. Empty attrs
/// are ignored by the filter parser.
fn opt_attr_val(attr: &Option<String>) -> Option<String> {
    if let Some(a) = attr {
        return Some(a.clone());
    }
    return Some(String::new());
}

impl Serialize for FeedItem {
    /// JSON serialization attributes.
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut state = serializer.serialize_struct("FeedItem", 10)?;
        state.serialize_field("title", &self.title)?;
        state.serialize_field("url", &self.url)?;
        state.serialize_field("date", &self.date)?;
        state.serialize_field("author", &self.author)?;
        state.serialize_field("unread", &self.unread)?;
        state.serialize_field("desc", &self.desc)?;
        state.serialize_field("content", &self.content)?;
        state.serialize_field("flags", &self.flags)?;
        state.serialize_field("enclosureUrl", &self.enc_url)?;
        state.serialize_field("enclosureMime", &self.enc_mime)?;
        state.end()
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_matching_basic_feed_item_attrs() {
        let item = FeedItem::new(
            "item1",
            "http://test.com",
            "",
            "exaroth",
            "Test feed item",
            123456,
            false,
            "Test content",
            1,
        );
        let mut attr = item.attribute_value("title");
        assert_eq!(Some("item1".to_string()), attr);
        attr = item.attribute_value("link");
        assert_eq!(Some("http://test.com".to_string()), attr);
        attr = item.attribute_value("author");
        assert_eq!(Some("exaroth".to_string()), attr);
        attr = item.attribute_value("unread");
        assert_eq!(Some("no".to_string()), attr);
        attr = item.attribute_value("date");
        assert_eq!(Some("123456".to_string()), attr);
        attr = item.attribute_value("age");
        assert_eq!(Some("20067".to_string()), attr);
        attr = item.attribute_value("content");
        assert_eq!(Some("Test content".to_string()), attr);
        attr = item.attribute_value("guid");
        assert_eq!(Some("1".to_string()), attr);
    }

    #[test]
    fn test_matching_optional_feed_item_attrs() {
        let mut item = FeedItem::new(
            "item1",
            "http://test.com",
            "",
            "exaroth",
            "Test feed item",
            123456,
            false,
            "Test content",
            1,
        );
        let mut attr = item.attribute_value("enclosure_url");
        assert_eq!(Some("".to_string()), attr);
        attr = item.attribute_value("enclosure_type");
        assert_eq!(Some("".to_string()), attr);
        attr = item.attribute_value("flags");
        assert_eq!(Some("".to_string()), attr);
        item.enc_url = Some("http://test.com".to_string());
        item.enc_mime = Some("video/mp4".to_string());
        item.flags = Some("flag1 flag2".to_string());
        attr = item.attribute_value("enclosure_url");
        assert_eq!(Some("http://test.com".to_string()), attr);
        attr = item.attribute_value("enclosure_type");
        assert_eq!(Some("video/mp4".to_string()), attr);
        attr = item.attribute_value("flags");
        assert_eq!(Some("flag1 flag2".to_string()), attr);
    }

    #[test]
    fn test_falling_back_to_feed_attribute_if_not_found() {
        let f = Arc::new(RefCell::new(Feed::init(
            "http://feed.com".to_string(),
            "Feed".to_string(),
            "http://feedlink.com".to_string(),
        )));
        let mut item = FeedItem::new(
            "item1",
            "http://test.com",
            "",
            "",
            "",
            970000000,
            false,
            "",
            1,
        );
        item.set_ptr(Arc::clone(&f));
        f.borrow_mut().add_item(item);
        let mut attr = f.borrow().items[0].attribute_value("feedlink");
        assert_eq!(Some("http://feedlink.com".to_string()), attr);
        attr = f.borrow().items[0].attribute_value("rssurl");
        assert_eq!(Some("http://feed.com".to_string()), attr);
        attr = f.borrow().items[0].attribute_value("nonexistent");
        assert!(attr.is_none());
    }
}
